#include <msp430.h>

// Flash definitions (W25Q80DVSNIG)
#define WriteEnable 0x06;
#define VolatileSRWriteEN 0x50;
#define WriteDisable 0x04;
#define ReadSR1 0x05;
#define ReadSR2 0x35;
#define WriteSR 0x01;
#define PageProgram 0x02;          // Same as WriteData
#define SectorErase_4KB 0x20;
#define BlockErase_32KB 0x52;
#define BlockErase_64KB 0xD8;
#define ChipErase 0xC7;
#define ProgramSuspend 0x75;
#define ProgramResume 0x7A;
#define PowerDown 0xB9;
#define ReadData 0x03;
#define FastRead 0x0B;
#define ReleasePDID 0xAB;
#define JEDECID 0x9F;
#define ReadUniqueID 0x4B;
#define EnableReset 0x66;
#define Reset 0x99;
#define DummyByte 0xA5;

#define BUTTON BIT3
#define CS BIT4;

char value [] = "h";
int i = 0;
volatile int j=0;

void serialTransmit (char *str);
char receiveByte (void);
void sendByte (char byte);
char readSR (char readSRx);
void writeSR (char SR_addr, char SR_data);
long readData (unsigned long addr);
void writeData (char addr, char data);

void main (void) {
     WDTCTL = WDTPW | WDTHOLD; // disabling the watchdog timer

    BCSCTL1 = CALBC1_1MHZ;
    DCOCTL = CALDCO_1MHZ; // setting the clock rate to 1MHz

    P1IE |= BUTTON;
    P1IES |= BUTTON;
    P1IFG &= ~BUTTON;
    _enable_interrupts();

    P1DIR |= CS;
    P1OUT |= CS;
    P1SEL = BIT5 | BIT6 | BIT7;
    P1SEL2 = BIT5 | BIT6 | BIT7;
    UCB0CTL1 |= UCSWRST + UCSSEL_2;
    UCB0CTL0 |= UCCKPH + UCMSB + UCMST + UCSYNC;
    UCB0BR0 = 10;
    UCB0CTL1 &= ~UCSWRST;

    IE2 |= UCB0RXIE;
//    IE2 |= UCB0TXIE;

    while (1);
}

void serialTransmit (char *str) {
    while (*str != 0) {
        while (!(IFG2 & UCB0TXIFG));
        UCB0TXBUF = *str++;
    }
}

char receiveByte (void) {
    while (!(IFG2 & UCB0RXIFG));
    return UCB0RXBUF;
}

void sendByte (char byte) {
    while (!(IFG2 & UCB0TXIFG));
    UCB0TXBUF = byte;
}

char readSR (char readSRx) {
    char RSR = 0;
    P1OUT &= ~CS;
    sendByte(readSRx);
    RSR = receiveByte();
    P1OUT |= CS;
    return RSR;
}

void writeSR (char SR_addr, char SR_data) {
    P1OUT &= ~CS;
    sendByte(WriteEnable);
    sendByte(SR_addr);
    sendByte(SR_data);
    sendByte(WriteDisable);
    P1OUT |= CS;
}

long readData (unsigned long addr) {
    char data = 0;
    P1OUT &= ~CS;
    sendByte((addr >> 16) & (0xFF));
    sendByte((addr >> 8) & (0xFF));
    sendByte(addr & 0xFF);
    data = receiveByte();
    P1OUT |= CS;
    return data;
}

void writeData (char addr, char data) {
    P1OUT &= ~CS;
    sendByte(WriteEnable);
    sendByte(addr);
    sendByte(data);
    sendByte(WriteDisable);
    P1OUT |= CS;
}

#pragma vector=PORT1_VECTOR
__interrupt void PORT1_ISR (void) {
    serial_transmit("h");
    P1IFG &= ~BUTTON;
}

// #pragma vector=USCIAB0RX_VECTOR
// __interrupt void USCIAB0RX_ISR (void) {
//     *(value + i) = UCB0RXBUF;
//     if (*(value + i) != 0)
//         i++;
//     else
//         i=0;
// }
